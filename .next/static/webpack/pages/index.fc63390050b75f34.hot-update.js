"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/importUtils.js":
/*!****************************!*\
  !*** ./lib/importUtils.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"importPlayers\": function() { return /* binding */ importPlayers; },\n/* harmony export */   \"importSchedule\": function() { return /* binding */ importSchedule; },\n/* harmony export */   \"parseCSV\": function() { return /* binding */ parseCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _models_Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Player */ \"./models/Player.js\");\n/* harmony import */ var _models_Team__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Team */ \"./models/Team.js\");\n/* harmony import */ var _models_Match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Match */ \"./models/Match.js\");\n\n\n\n\n/**\n * Parse CSV data from string\n * @param {string} csvString - CSV data as string \n * @returns {Array} Parsed data\n */ function parseCSV(csvString) {\n    var result = papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(csvString, {\n        skipEmptyLines: true,\n        header: false\n    });\n    if (result.errors && result.errors.length > 0) {\n        throw new Error(\"Error parsing CSV: \".concat(result.errors[0].message));\n    }\n    return result.data;\n}\n/**\n * Import player data from CSV string\n * @param {string} csvString - CSV data as string\n * @returns {Array} Array of Player objects\n */ function importPlayers(csvString) {\n    var data = parseCSV(csvString);\n    // Skip header row if it exists\n    var hasHeader = isHeaderRow(data[0]);\n    var playerData = hasHeader ? data.slice(1) : data;\n    return playerData.map(function(row) {\n        return _models_Player__WEBPACK_IMPORTED_MODULE_1__.Player.fromRow(row);\n    });\n}\n/**\n * Import schedule data from CSV string\n * @param {string} csvString - CSV data as string\n * @param {Object} teamsMap - Map of team names to Team objects by division\n * @returns {Array} Array of Match objects\n */ function importSchedule(csvString, teamsMap) {\n    var data = parseCSV(csvString);\n    // Skip header row if it exists\n    var hasHeader = isScheduleHeaderRow(data[0]);\n    var scheduleData = hasHeader ? data.slice(1) : data;\n    // Filter out empty rows and special rows (SETUP, PACKING DOWN)\n    scheduleData = scheduleData.filter(function(row) {\n        // Skip completely empty rows\n        if (row.every(function(cell) {\n            return !cell || cell.trim() === \"\";\n        })) return false;\n        // Check if this is a special row like SETUP or PACKING DOWN\n        var isSpecialRow = row.some(function(cell) {\n            return cell && typeof cell === \"string\" && (cell.includes(\"SETUP\") || cell.includes(\"PACKING DOWN\"));\n        });\n        return !isSpecialRow;\n    });\n    return processScheduleFormat(scheduleData, teamsMap);\n}\n/**\n * Process schedule data based on format detection\n * @param {Array} scheduleData - Parsed schedule data\n * @param {Object} teamsMap - Map of team names to Team objects by division\n * @returns {Array} Array of Match objects\n */ function processScheduleFormat(scheduleData, teamsMap) {\n    var matches = [];\n    var currentDivision = \"\";\n    var timeSlotCounter = 1;\n    for(var i = 0; i < scheduleData.length; i++){\n        var row = scheduleData[i];\n        // Skip rows that are too short\n        if (row.length < 6) continue;\n        // Check if this row contains a division header\n        if (row[0] && !row[2] && !row[3] && row[0] !== \"Round\") {\n            currentDivision = row[0].toLowerCase();\n            continue;\n        }\n        // Format detection and extraction\n        var division = void 0, time = void 0, team1 = void 0, team2 = void 0, field = void 0, refereeTeam = void 0;\n        // Try to detect if this is the tournament-specific format\n        if (row[0] === \"\" && row[1] && row[2] && row[3] && row[4]) {\n            // This is likely the tournament format where div is in column 1\n            division = (row[1] || currentDivision || \"\").toLowerCase();\n            time = row[2] || \"\";\n            team1 = row[3] || \"\";\n            team2 = row[4] || \"\";\n            field = row[5] || \"\";\n            refereeTeam = row[6] || \"\";\n        } else {\n            // Try generic format or fallback\n            division = (row[1] || currentDivision || \"\").toLowerCase();\n            time = row[2] || \"\";\n            team1 = row[3] || \"\";\n            team2 = row[4] || \"\";\n            field = row[5] || \"\";\n            refereeTeam = row[6] || \"\";\n            // If division is empty or doesn't match expected format, try different column mapping\n            if (!division || !division.match(/^(mx|m|w)/i)) {\n                var firstCol = (row[0] || \"\").toLowerCase();\n                if (firstCol.match(/^(mx|m|w)/i)) {\n                    // Division is in first column\n                    division = firstCol;\n                    // Shift other columns if needed\n                    if (!time && row[1]) time = row[1];\n                    if (!team1 && row[2]) team1 = row[2];\n                    if (!team2 && row[3]) team2 = row[3];\n                    if (!field && row[4]) field = row[4];\n                    if (!refereeTeam && row[5]) refereeTeam = row[5];\n                }\n            }\n        }\n        // Skip if essential data is missing\n        if (!division || !team1 || !team2) continue;\n        // Normalize division format (mx1, mx2, m1, m2, w)\n        var normalizedDivision = division.toLowerCase();\n        if (normalizedDivision.startsWith(\"mx\")) {\n            normalizedDivision = \"mixed\";\n        } else if (normalizedDivision.startsWith(\"m\")) {\n            normalizedDivision = \"gendered\";\n        } else if (normalizedDivision.startsWith(\"w\")) {\n            normalizedDivision = \"gendered\";\n        } else {\n            // Use division from context if available\n            normalizedDivision = currentDivision || \"mixed\";\n        }\n        // Convert time to slot number if it's a time string\n        var timeSlot = timeSlotCounter++;\n        if (time && time.includes(\":\")) {\n            // It's a time string, convert to numerical order\n            var timeParts = time.split(\":\");\n            if (timeParts.length === 2) {\n                var hours = parseInt(timeParts[0]);\n                var minutes = parseInt(timeParts[1]);\n                // Create a time value for sorting (e.g., 9:30 becomes 930)\n                timeSlot = hours * 100 + minutes;\n            }\n        }\n        // Look up teams in the team map\n        var divTeams = teamsMap[normalizedDivision] || {};\n        // Create teams if they don't exist in the map\n        if (!divTeams[team1]) {\n            divTeams[team1] = new _models_Team__WEBPACK_IMPORTED_MODULE_2__.Team(team1, normalizedDivision);\n        }\n        if (!divTeams[team2]) {\n            divTeams[team2] = new _models_Team__WEBPACK_IMPORTED_MODULE_2__.Team(team2, normalizedDivision);\n        }\n        // Look up referee team if provided\n        var refTeam = null;\n        if (refereeTeam && refereeTeam !== \"-\") {\n            // Extract team name if it has division in parentheses, e.g., \"Team Name (MX)\"\n            var refTeamName = refereeTeam.split(\"(\")[0].trim();\n            if (divTeams[refTeamName]) {\n                refTeam = divTeams[refTeamName];\n            } else {\n                // Try to find the referee team in any division\n                for(var div in teamsMap){\n                    if (teamsMap[div][refTeamName]) {\n                        refTeam = teamsMap[div][refTeamName];\n                        break;\n                    }\n                }\n                // If still not found, create it\n                if (!refTeam) {\n                    refTeam = new _models_Team__WEBPACK_IMPORTED_MODULE_2__.Team(refTeamName, normalizedDivision);\n                    divTeams[refTeamName] = refTeam;\n                }\n            }\n        }\n        // Create the match\n        var match = new _models_Match__WEBPACK_IMPORTED_MODULE_3__.Match(divTeams[team1], divTeams[team2], timeSlot, field, normalizedDivision, refTeam);\n        matches.push(match);\n    }\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        // Update the teams map with any new teams\n        for(var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var match1 = _step.value;\n            if (!teamsMap[match1.division]) {\n                teamsMap[match1.division] = {};\n            }\n            if (!teamsMap[match1.division][match1.team1.name]) {\n                teamsMap[match1.division][match1.team1.name] = match1.team1;\n            }\n            if (!teamsMap[match1.division][match1.team2.name]) {\n                teamsMap[match1.division][match1.team2.name] = match1.team2;\n            }\n            if (match1.refereeTeam && !teamsMap[match1.division][match1.refereeTeam.name]) {\n                teamsMap[match1.division][match1.refereeTeam.name] = match1.refereeTeam;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return matches;\n}\n/**\n * Check if a row is likely a header row for player data\n * @param {Array} row - Row data\n * @returns {boolean} True if row appears to be a header\n */ function isHeaderRow(row) {\n    if (!row || row.length === 0) return false;\n    // Check if first value is a non-numeric string like \"Name\" or \"Player\"\n    var firstCell = String(row[0]).toLowerCase();\n    return isNaN(firstCell) && (firstCell.includes(\"name\") || firstCell.includes(\"player\") || firstCell.includes(\"team\"));\n}\n/**\n * Check if a row is likely a header row for schedule data\n * @param {Array} row - Row data\n * @returns {boolean} True if row appears to be a header\n */ function isScheduleHeaderRow(row) {\n    if (!row || row.length === 0) return false;\n    // Check for common schedule header columns\n    var headerKeywords = [\n        \"round\",\n        \"division\",\n        \"time\",\n        \"team\",\n        \"court\",\n        \"field\",\n        \"referee\"\n    ];\n    // Count how many cells contain header keywords\n    var headerKeywordCount = 0;\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        var _loop = function() {\n            var cell = _step.value;\n            var cellText = String(cell).toLowerCase();\n            if (headerKeywords.some(function(keyword) {\n                return cellText.includes(keyword);\n            })) {\n                headerKeywordCount++;\n            }\n        };\n        for(var _iterator = row[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // If at least 3 header keywords are found, consider it a header row\n    return headerKeywordCount >= 3;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ3ZCLENBQUM7UUFDSDtRQUxBLFFBQUssU0FBVSxHQUFJN0MsR0FBRyxxQkFBakIsS0FBVSxJQUFWLHlCQUFVLElBQVYsS0FBVSxHQUFWLFNBQVUsZ0JBQVYseUJBQVU7O1FBQVYsaUJBQVU7UUFBVixjQUFVOzs7aUJBQVYseUJBQVUsSUFBVixTQUFVO2dCQUFWLFNBQVU7OztnQkFBVixpQkFBVTtzQkFBVixjQUFVOzs7O0lBT2Ysb0VBQW9FO0lBQ3BFLE9BQU82QyxrQkFBa0IsSUFBSSxDQUFDLENBQUM7QUFDakMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaW1wb3J0VXRpbHMuanM/ZDE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnO1xuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vbW9kZWxzL1BsYXllcic7XG5pbXBvcnQgeyBUZWFtIH0gZnJvbSAnLi4vbW9kZWxzL1RlYW0nO1xuaW1wb3J0IHsgTWF0Y2ggfSBmcm9tICcuLi9tb2RlbHMvTWF0Y2gnO1xuXG4vKipcbiAqIFBhcnNlIENTViBkYXRhIGZyb20gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gY3N2U3RyaW5nIC0gQ1NWIGRhdGEgYXMgc3RyaW5nIFxuICogQHJldHVybnMge0FycmF5fSBQYXJzZWQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDU1YoY3N2U3RyaW5nKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFBhcGEucGFyc2UoY3N2U3RyaW5nLCB7XG4gICAgc2tpcEVtcHR5TGluZXM6IHRydWUsXG4gICAgaGVhZGVyOiBmYWxzZVxuICB9KTtcbiAgXG4gIGlmIChyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcGFyc2luZyBDU1Y6ICR7cmVzdWx0LmVycm9yc1swXS5tZXNzYWdlfWApO1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0LmRhdGE7XG59XG5cbi8qKlxuICogSW1wb3J0IHBsYXllciBkYXRhIGZyb20gQ1NWIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGNzdlN0cmluZyAtIENTViBkYXRhIGFzIHN0cmluZ1xuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBQbGF5ZXIgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0UGxheWVycyhjc3ZTdHJpbmcpIHtcbiAgY29uc3QgZGF0YSA9IHBhcnNlQ1NWKGNzdlN0cmluZyk7XG4gIFxuICAvLyBTa2lwIGhlYWRlciByb3cgaWYgaXQgZXhpc3RzXG4gIGNvbnN0IGhhc0hlYWRlciA9IGlzSGVhZGVyUm93KGRhdGFbMF0pO1xuICBjb25zdCBwbGF5ZXJEYXRhID0gaGFzSGVhZGVyID8gZGF0YS5zbGljZSgxKSA6IGRhdGE7XG4gIFxuICByZXR1cm4gcGxheWVyRGF0YS5tYXAocm93ID0+IFBsYXllci5mcm9tUm93KHJvdykpO1xufVxuXG4vKipcbiAqIEltcG9ydCBzY2hlZHVsZSBkYXRhIGZyb20gQ1NWIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGNzdlN0cmluZyAtIENTViBkYXRhIGFzIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IHRlYW1zTWFwIC0gTWFwIG9mIHRlYW0gbmFtZXMgdG8gVGVhbSBvYmplY3RzIGJ5IGRpdmlzaW9uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIE1hdGNoIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydFNjaGVkdWxlKGNzdlN0cmluZywgdGVhbXNNYXApIHtcbiAgY29uc3QgZGF0YSA9IHBhcnNlQ1NWKGNzdlN0cmluZyk7XG4gIFxuICAvLyBTa2lwIGhlYWRlciByb3cgaWYgaXQgZXhpc3RzXG4gIGNvbnN0IGhhc0hlYWRlciA9IGlzU2NoZWR1bGVIZWFkZXJSb3coZGF0YVswXSk7XG4gIGxldCBzY2hlZHVsZURhdGEgPSBoYXNIZWFkZXIgPyBkYXRhLnNsaWNlKDEpIDogZGF0YTtcbiAgXG4gIC8vIEZpbHRlciBvdXQgZW1wdHkgcm93cyBhbmQgc3BlY2lhbCByb3dzIChTRVRVUCwgUEFDS0lORyBET1dOKVxuICBzY2hlZHVsZURhdGEgPSBzY2hlZHVsZURhdGEuZmlsdGVyKHJvdyA9PiB7XG4gICAgLy8gU2tpcCBjb21wbGV0ZWx5IGVtcHR5IHJvd3NcbiAgICBpZiAocm93LmV2ZXJ5KGNlbGwgPT4gIWNlbGwgfHwgY2VsbC50cmltKCkgPT09IFwiXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHNwZWNpYWwgcm93IGxpa2UgU0VUVVAgb3IgUEFDS0lORyBET1dOXG4gICAgY29uc3QgaXNTcGVjaWFsUm93ID0gcm93LnNvbWUoY2VsbCA9PiBcbiAgICAgIGNlbGwgJiYgdHlwZW9mIGNlbGwgPT09ICdzdHJpbmcnICYmIFxuICAgICAgKGNlbGwuaW5jbHVkZXMoJ1NFVFVQJykgfHwgY2VsbC5pbmNsdWRlcygnUEFDS0lORyBET1dOJykpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gIWlzU3BlY2lhbFJvdztcbiAgfSk7XG4gIFxuICByZXR1cm4gcHJvY2Vzc1NjaGVkdWxlRm9ybWF0KHNjaGVkdWxlRGF0YSwgdGVhbXNNYXApO1xufVxuXG4vKipcbiAqIFByb2Nlc3Mgc2NoZWR1bGUgZGF0YSBiYXNlZCBvbiBmb3JtYXQgZGV0ZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBzY2hlZHVsZURhdGEgLSBQYXJzZWQgc2NoZWR1bGUgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IHRlYW1zTWFwIC0gTWFwIG9mIHRlYW0gbmFtZXMgdG8gVGVhbSBvYmplY3RzIGJ5IGRpdmlzaW9uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIE1hdGNoIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1NjaGVkdWxlRm9ybWF0KHNjaGVkdWxlRGF0YSwgdGVhbXNNYXApIHtcbiAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICBsZXQgY3VycmVudERpdmlzaW9uID0gXCJcIjtcbiAgbGV0IHRpbWVTbG90Q291bnRlciA9IDE7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVkdWxlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IHNjaGVkdWxlRGF0YVtpXTtcbiAgICBcbiAgICAvLyBTa2lwIHJvd3MgdGhhdCBhcmUgdG9vIHNob3J0XG4gICAgaWYgKHJvdy5sZW5ndGggPCA2KSBjb250aW51ZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvdyBjb250YWlucyBhIGRpdmlzaW9uIGhlYWRlclxuICAgIGlmIChyb3dbMF0gJiYgIXJvd1syXSAmJiAhcm93WzNdICYmIHJvd1swXSAhPT0gXCJSb3VuZFwiKSB7XG4gICAgICBjdXJyZW50RGl2aXNpb24gPSByb3dbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3JtYXQgZGV0ZWN0aW9uIGFuZCBleHRyYWN0aW9uXG4gICAgbGV0IGRpdmlzaW9uLCB0aW1lLCB0ZWFtMSwgdGVhbTIsIGZpZWxkLCByZWZlcmVlVGVhbTtcbiAgICBcbiAgICAvLyBUcnkgdG8gZGV0ZWN0IGlmIHRoaXMgaXMgdGhlIHRvdXJuYW1lbnQtc3BlY2lmaWMgZm9ybWF0XG4gICAgaWYgKHJvd1swXSA9PT0gXCJcIiAmJiByb3dbMV0gJiYgcm93WzJdICYmIHJvd1szXSAmJiByb3dbNF0pIHtcbiAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IHRoZSB0b3VybmFtZW50IGZvcm1hdCB3aGVyZSBkaXYgaXMgaW4gY29sdW1uIDFcbiAgICAgIGRpdmlzaW9uID0gKHJvd1sxXSB8fCBjdXJyZW50RGl2aXNpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRpbWUgPSByb3dbMl0gfHwgXCJcIjtcbiAgICAgIHRlYW0xID0gcm93WzNdIHx8IFwiXCI7XG4gICAgICB0ZWFtMiA9IHJvd1s0XSB8fCBcIlwiO1xuICAgICAgZmllbGQgPSByb3dbNV0gfHwgXCJcIjtcbiAgICAgIHJlZmVyZWVUZWFtID0gcm93WzZdIHx8IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyeSBnZW5lcmljIGZvcm1hdCBvciBmYWxsYmFja1xuICAgICAgZGl2aXNpb24gPSAocm93WzFdIHx8IGN1cnJlbnREaXZpc2lvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGltZSA9IHJvd1syXSB8fCBcIlwiO1xuICAgICAgdGVhbTEgPSByb3dbM10gfHwgXCJcIjtcbiAgICAgIHRlYW0yID0gcm93WzRdIHx8IFwiXCI7XG4gICAgICBmaWVsZCA9IHJvd1s1XSB8fCBcIlwiO1xuICAgICAgcmVmZXJlZVRlYW0gPSByb3dbNl0gfHwgXCJcIjtcbiAgICAgIFxuICAgICAgLy8gSWYgZGl2aXNpb24gaXMgZW1wdHkgb3IgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBmb3JtYXQsIHRyeSBkaWZmZXJlbnQgY29sdW1uIG1hcHBpbmdcbiAgICAgIGlmICghZGl2aXNpb24gfHwgIWRpdmlzaW9uLm1hdGNoKC9eKG14fG18dykvaSkpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDb2wgPSAocm93WzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChmaXJzdENvbC5tYXRjaCgvXihteHxtfHcpL2kpKSB7XG4gICAgICAgICAgLy8gRGl2aXNpb24gaXMgaW4gZmlyc3QgY29sdW1uXG4gICAgICAgICAgZGl2aXNpb24gPSBmaXJzdENvbDtcbiAgICAgICAgICAvLyBTaGlmdCBvdGhlciBjb2x1bW5zIGlmIG5lZWRlZFxuICAgICAgICAgIGlmICghdGltZSAmJiByb3dbMV0pIHRpbWUgPSByb3dbMV07XG4gICAgICAgICAgaWYgKCF0ZWFtMSAmJiByb3dbMl0pIHRlYW0xID0gcm93WzJdO1xuICAgICAgICAgIGlmICghdGVhbTIgJiYgcm93WzNdKSB0ZWFtMiA9IHJvd1szXTtcbiAgICAgICAgICBpZiAoIWZpZWxkICYmIHJvd1s0XSkgZmllbGQgPSByb3dbNF07XG4gICAgICAgICAgaWYgKCFyZWZlcmVlVGVhbSAmJiByb3dbNV0pIHJlZmVyZWVUZWFtID0gcm93WzVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNraXAgaWYgZXNzZW50aWFsIGRhdGEgaXMgbWlzc2luZ1xuICAgIGlmICghZGl2aXNpb24gfHwgIXRlYW0xIHx8ICF0ZWFtMikgY29udGludWU7XG4gICAgXG4gICAgLy8gTm9ybWFsaXplIGRpdmlzaW9uIGZvcm1hdCAobXgxLCBteDIsIG0xLCBtMiwgdylcbiAgICBsZXQgbm9ybWFsaXplZERpdmlzaW9uID0gZGl2aXNpb24udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9ybWFsaXplZERpdmlzaW9uLnN0YXJ0c1dpdGgoXCJteFwiKSkge1xuICAgICAgbm9ybWFsaXplZERpdmlzaW9uID0gXCJtaXhlZFwiO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZERpdmlzaW9uLnN0YXJ0c1dpdGgoXCJtXCIpKSB7XG4gICAgICBub3JtYWxpemVkRGl2aXNpb24gPSBcImdlbmRlcmVkXCI7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkRGl2aXNpb24uc3RhcnRzV2l0aChcIndcIikpIHtcbiAgICAgIG5vcm1hbGl6ZWREaXZpc2lvbiA9IFwiZ2VuZGVyZWRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIGRpdmlzaW9uIGZyb20gY29udGV4dCBpZiBhdmFpbGFibGVcbiAgICAgIG5vcm1hbGl6ZWREaXZpc2lvbiA9IGN1cnJlbnREaXZpc2lvbiB8fCBcIm1peGVkXCI7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgdGltZSB0byBzbG90IG51bWJlciBpZiBpdCdzIGEgdGltZSBzdHJpbmdcbiAgICBsZXQgdGltZVNsb3QgPSB0aW1lU2xvdENvdW50ZXIrKztcbiAgICBpZiAodGltZSAmJiB0aW1lLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgLy8gSXQncyBhIHRpbWUgc3RyaW5nLCBjb252ZXJ0IHRvIG51bWVyaWNhbCBvcmRlclxuICAgICAgY29uc3QgdGltZVBhcnRzID0gdGltZS5zcGxpdChcIjpcIik7XG4gICAgICBpZiAodGltZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBjb25zdCBob3VycyA9IHBhcnNlSW50KHRpbWVQYXJ0c1swXSk7XG4gICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lUGFydHNbMV0pO1xuICAgICAgICAvLyBDcmVhdGUgYSB0aW1lIHZhbHVlIGZvciBzb3J0aW5nIChlLmcuLCA5OjMwIGJlY29tZXMgOTMwKVxuICAgICAgICB0aW1lU2xvdCA9IGhvdXJzICogMTAwICsgbWludXRlcztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTG9vayB1cCB0ZWFtcyBpbiB0aGUgdGVhbSBtYXBcbiAgICBsZXQgZGl2VGVhbXMgPSB0ZWFtc01hcFtub3JtYWxpemVkRGl2aXNpb25dIHx8IHt9O1xuICAgIFxuICAgIC8vIENyZWF0ZSB0ZWFtcyBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSBtYXBcbiAgICBpZiAoIWRpdlRlYW1zW3RlYW0xXSkge1xuICAgICAgZGl2VGVhbXNbdGVhbTFdID0gbmV3IFRlYW0odGVhbTEsIG5vcm1hbGl6ZWREaXZpc2lvbik7XG4gICAgfVxuICAgIFxuICAgIGlmICghZGl2VGVhbXNbdGVhbTJdKSB7XG4gICAgICBkaXZUZWFtc1t0ZWFtMl0gPSBuZXcgVGVhbSh0ZWFtMiwgbm9ybWFsaXplZERpdmlzaW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTG9vayB1cCByZWZlcmVlIHRlYW0gaWYgcHJvdmlkZWRcbiAgICBsZXQgcmVmVGVhbSA9IG51bGw7XG4gICAgaWYgKHJlZmVyZWVUZWFtICYmIHJlZmVyZWVUZWFtICE9PSBcIi1cIikge1xuICAgICAgLy8gRXh0cmFjdCB0ZWFtIG5hbWUgaWYgaXQgaGFzIGRpdmlzaW9uIGluIHBhcmVudGhlc2VzLCBlLmcuLCBcIlRlYW0gTmFtZSAoTVgpXCJcbiAgICAgIGNvbnN0IHJlZlRlYW1OYW1lID0gcmVmZXJlZVRlYW0uc3BsaXQoXCIoXCIpWzBdLnRyaW0oKTtcbiAgICAgIFxuICAgICAgaWYgKGRpdlRlYW1zW3JlZlRlYW1OYW1lXSkge1xuICAgICAgICByZWZUZWFtID0gZGl2VGVhbXNbcmVmVGVhbU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIHJlZmVyZWUgdGVhbSBpbiBhbnkgZGl2aXNpb25cbiAgICAgICAgZm9yIChjb25zdCBkaXYgaW4gdGVhbXNNYXApIHtcbiAgICAgICAgICBpZiAodGVhbXNNYXBbZGl2XVtyZWZUZWFtTmFtZV0pIHtcbiAgICAgICAgICAgIHJlZlRlYW0gPSB0ZWFtc01hcFtkaXZdW3JlZlRlYW1OYW1lXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBjcmVhdGUgaXRcbiAgICAgICAgaWYgKCFyZWZUZWFtKSB7XG4gICAgICAgICAgcmVmVGVhbSA9IG5ldyBUZWFtKHJlZlRlYW1OYW1lLCBub3JtYWxpemVkRGl2aXNpb24pO1xuICAgICAgICAgIGRpdlRlYW1zW3JlZlRlYW1OYW1lXSA9IHJlZlRlYW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBtYXRjaFxuICAgIGNvbnN0IG1hdGNoID0gbmV3IE1hdGNoKFxuICAgICAgZGl2VGVhbXNbdGVhbTFdLFxuICAgICAgZGl2VGVhbXNbdGVhbTJdLFxuICAgICAgdGltZVNsb3QsXG4gICAgICBmaWVsZCxcbiAgICAgIG5vcm1hbGl6ZWREaXZpc2lvbixcbiAgICAgIHJlZlRlYW1cbiAgICApO1xuICAgIFxuICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gIH1cbiAgXG4gIC8vIFVwZGF0ZSB0aGUgdGVhbXMgbWFwIHdpdGggYW55IG5ldyB0ZWFtc1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBpZiAoIXRlYW1zTWFwW21hdGNoLmRpdmlzaW9uXSkge1xuICAgICAgdGVhbXNNYXBbbWF0Y2guZGl2aXNpb25dID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmICghdGVhbXNNYXBbbWF0Y2guZGl2aXNpb25dW21hdGNoLnRlYW0xLm5hbWVdKSB7XG4gICAgICB0ZWFtc01hcFttYXRjaC5kaXZpc2lvbl1bbWF0Y2gudGVhbTEubmFtZV0gPSBtYXRjaC50ZWFtMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0ZWFtc01hcFttYXRjaC5kaXZpc2lvbl1bbWF0Y2gudGVhbTIubmFtZV0pIHtcbiAgICAgIHRlYW1zTWFwW21hdGNoLmRpdmlzaW9uXVttYXRjaC50ZWFtMi5uYW1lXSA9IG1hdGNoLnRlYW0yO1xuICAgIH1cbiAgICBcbiAgICBpZiAobWF0Y2gucmVmZXJlZVRlYW0gJiYgIXRlYW1zTWFwW21hdGNoLmRpdmlzaW9uXVttYXRjaC5yZWZlcmVlVGVhbS5uYW1lXSkge1xuICAgICAgdGVhbXNNYXBbbWF0Y2guZGl2aXNpb25dW21hdGNoLnJlZmVyZWVUZWFtLm5hbWVdID0gbWF0Y2gucmVmZXJlZVRlYW07XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHJvdyBpcyBsaWtlbHkgYSBoZWFkZXIgcm93IGZvciBwbGF5ZXIgZGF0YVxuICogQHBhcmFtIHtBcnJheX0gcm93IC0gUm93IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHJvdyBhcHBlYXJzIHRvIGJlIGEgaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGlzSGVhZGVyUm93KHJvdykge1xuICBpZiAoIXJvdyB8fCByb3cubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBDaGVjayBpZiBmaXJzdCB2YWx1ZSBpcyBhIG5vbi1udW1lcmljIHN0cmluZyBsaWtlIFwiTmFtZVwiIG9yIFwiUGxheWVyXCJcbiAgY29uc3QgZmlyc3RDZWxsID0gU3RyaW5nKHJvd1swXSkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGlzTmFOKGZpcnN0Q2VsbCkgJiYgXG4gICAgKGZpcnN0Q2VsbC5pbmNsdWRlcygnbmFtZScpIHx8IFxuICAgICBmaXJzdENlbGwuaW5jbHVkZXMoJ3BsYXllcicpIHx8XG4gICAgIGZpcnN0Q2VsbC5pbmNsdWRlcygndGVhbScpKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHJvdyBpcyBsaWtlbHkgYSBoZWFkZXIgcm93IGZvciBzY2hlZHVsZSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSByb3cgLSBSb3cgZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgcm93IGFwcGVhcnMgdG8gYmUgYSBoZWFkZXJcbiAqL1xuZnVuY3Rpb24gaXNTY2hlZHVsZUhlYWRlclJvdyhyb3cpIHtcbiAgaWYgKCFyb3cgfHwgcm93Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBzY2hlZHVsZSBoZWFkZXIgY29sdW1uc1xuICBjb25zdCBoZWFkZXJLZXl3b3JkcyA9IFsncm91bmQnLCAnZGl2aXNpb24nLCAndGltZScsICd0ZWFtJywgJ2NvdXJ0JywgJ2ZpZWxkJywgJ3JlZmVyZWUnXTtcbiAgXG4gIC8vIENvdW50IGhvdyBtYW55IGNlbGxzIGNvbnRhaW4gaGVhZGVyIGtleXdvcmRzXG4gIGxldCBoZWFkZXJLZXl3b3JkQ291bnQgPSAwO1xuICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgY29uc3QgY2VsbFRleHQgPSBTdHJpbmcoY2VsbCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaGVhZGVyS2V5d29yZHMuc29tZShrZXl3b3JkID0+IGNlbGxUZXh0LmluY2x1ZGVzKGtleXdvcmQpKSkge1xuICAgICAgaGVhZGVyS2V5d29yZENvdW50Kys7XG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiBhdCBsZWFzdCAzIGhlYWRlciBrZXl3b3JkcyBhcmUgZm91bmQsIGNvbnNpZGVyIGl0IGEgaGVhZGVyIHJvd1xuICByZXR1cm4gaGVhZGVyS2V5d29yZENvdW50ID49IDM7XG59Il0sIm5hbWVzIjpbIlBhcGEiLCJQbGF5ZXIiLCJUZWFtIiwiTWF0Y2giLCJwYXJzZUNTViIsImNzdlN0cmluZyIsInJlc3VsdCIsInBhcnNlIiwic2tpcEVtcHR5TGluZXMiLCJoZWFkZXIiLCJlcnJvcnMiLCJsZW5ndGgiLCJFcnJvciIsIm1lc3NhZ2UiLCJkYXRhIiwiaW1wb3J0UGxheWVycyIsImhhc0hlYWRlciIsImlzSGVhZGVyUm93IiwicGxheWVyRGF0YSIsInNsaWNlIiwibWFwIiwicm93IiwiZnJvbVJvdyIsImltcG9ydFNjaGVkdWxlIiwidGVhbXNNYXAiLCJpc1NjaGVkdWxlSGVhZGVyUm93Iiwic2NoZWR1bGVEYXRhIiwiZmlsdGVyIiwiZXZlcnkiLCJjZWxsIiwidHJpbSIsImlzU3BlY2lhbFJvdyIsInNvbWUiLCJpbmNsdWRlcyIsInByb2Nlc3NTY2hlZHVsZUZvcm1hdCIsIm1hdGNoZXMiLCJjdXJyZW50RGl2aXNpb24iLCJ0aW1lU2xvdENvdW50ZXIiLCJpIiwidG9Mb3dlckNhc2UiLCJkaXZpc2lvbiIsInRpbWUiLCJ0ZWFtMSIsInRlYW0yIiwiZmllbGQiLCJyZWZlcmVlVGVhbSIsIm1hdGNoIiwiZmlyc3RDb2wiLCJub3JtYWxpemVkRGl2aXNpb24iLCJzdGFydHNXaXRoIiwidGltZVNsb3QiLCJ0aW1lUGFydHMiLCJzcGxpdCIsImhvdXJzIiwicGFyc2VJbnQiLCJtaW51dGVzIiwiZGl2VGVhbXMiLCJyZWZUZWFtIiwicmVmVGVhbU5hbWUiLCJkaXYiLCJwdXNoIiwibmFtZSIsImZpcnN0Q2VsbCIsIlN0cmluZyIsImlzTmFOIiwiaGVhZGVyS2V5d29yZHMiLCJoZWFkZXJLZXl3b3JkQ291bnQiLCJjZWxsVGV4dCIsImtleXdvcmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/importUtils.js\n"));

/***/ })

});